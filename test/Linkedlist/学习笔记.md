# LinkedList
## 为什么需要虚拟头结点？头结点、头指针？

>这个问题可以参考链接 [头结点、头指针、首元结点](https://blog.csdn.net/qq_42615475/article/details/122181499?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&utm_relevant_index=2)

```c
//这里插入关于链表中有无头节点进行初始化链表知识
//首先明白头指针与头结点的关系：http://www.nowamagic.net/librarys/veda/detail/1805
//定义结点的结构体
//typedef struct LNode{
//	int data;
//	struct LNode *next;
//}LNode,*LinkList;//则定义LinkList L;时，L为链表的头指针。
//
//L=(LinkList) malloc (sizeof(LNode)); //创建一个结点，此处返回给L的是一个指针，并且赋给了头指针。
//L->next=null; //这里说明我创建了一个头结点，即同时运用了头指针和头结点。
//这么方便只要加上->next就说明创建了头节点。不过你想想头指针是没有next的，只有头结点才有，所以就不难理解了
 
 
//带头结点初始化
//Node *head;  //声明头结点
//首先第一眼看到(*head)->next=NULL;和我们刚才所说是不是一样，只要头指针一旦运用了next操作就自动创建了头结点
//但是我们今天的重点不在于这个，更多在于Node **head，对于两个指针的操作理解
//第一个指针*head，表明了head这个指针变量存储的是另外一个指向结构体NODE的指针，第二个指针，即*head作为一个整体
//其结果是一个指针，其指向的内容就是结构体NODE。经过这么一理解，对于头指针，头结点，首元节点的关系就非常明朗了
//	void InitList(Node **head){
//		*head=(Node *)malloc( sizeof(Node));//这里需要明确的第一点，申请内存返回的都是地址
//		//第二点就是（Node *）表明了其返回的指针指向最后的结果是NODE的结构体，如果是指向int，那么我们就写(int *)
//		(*head)->next=NULL;
//}
 
 
//带头结点尾方便了首元节点和其他节点一样，统一了操作
	//方式一：
//	void CreatList(Node **head){
//		Node *r=*head,*s;//因为前面已经对头结点，头指针初始化过了，因此可以直接使用*head
//		int a;
//		while(scanf("%d",&a)){
//			if(a!=0){
//				s=(Node *)malloc(sizeof(Node));
//				s->value=a;
//				r->next=s;//这里没有着急设置s->next，原因在于后续还要插入数据。因此将s赋值给r
//				r=s;    
//			}
//			else{    
//				r->next=NULL;//如果后续输入的数据为空，则就将其设置为null
//				break;    
//			}
//		}
//}
//调用CreatList(&head);//这句话表明了形参Node **head，只有第一个*才是起作用了，第个*号是和head联系在一起，作为整体使用的
 
 
//方式二：
//	void CreatList(Node *head){
//		Node *r=head,*s;
//		... //下面的都一样
//}
//调用CreatList(head)；
//
 
//不带头结点初始化
//方式一：
//void InitList(Node **head){
//		*head=NULL;//这里直接就是指向的首元节点，还有之前自己一个误解，看到head就觉得它就是头指针了，其实它就是随便一个指针变量
         //并不是像自己之前想的那样的
 
 
		//从这里才发现，真正有无头节点的区别。
		//*head=(Node *)malloc( sizeof(Node));//这里需要明确的第一点，申请内存返回的都是地址
		//第二点就是（Node *）表明了其返回的指针指向最后的结果是NODE的结构体，如果是指向int，那么我们就写(int *)
		//(*head)->next=NULL;
//}
//调用InitList(&head)；
//
//方式二：
//void InitList(Node *head){
//		head=NULL;
//}
//调用InitList(head)；
 
//不带头结点尾插入，第一个节点与其他节点分开操作
//void CreatList(Node  **head){
//		Node *p,*t;         /*p工作指针,t临时指针*/
//		int a,i=1;
//		while(scanf("%d",&a)){
//			if(a!=0){
//				t=(Node *)malloc(sizeof(Node));
//				t->value=a;
//				if(i==1){
//					*head=t;    
//				}
//				else{
//					p->next=t;
//				}
//				p=t;
//			}
//			else{    
//				p->next=NULL;
//				break;    
//			}
//			i++;
//		}
//}
//调用CreatList(&head)；
//其实从上面就可以知道，其实有头结点对于我们来说是一种更加明智更加方便的操作
```


## 1. reverse list
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。  
>leetcode 206

解法一：迭代  
思路：在遍历链表时，将当前结点的next指针指向前一个结点而不是下一个。由于结点没有指针指向其前一个结点，所以需要保存下前一个结点，在更改指针前，还需要保存后一个结点。
```java
class Solution{
    public ListNode reverselist(ListNode head){
        if (head == null || head.next == null){
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}
```
解法二：递归  
思路：  
base case：首元结点的next指向null。  
recursion rule: 对当前链表进行反转的子问题是对子链表已经完成反转。  
为防止出现环，要让首元结点的next一定指向null。
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);// 递归
        head.next.next = head;//边界条件，在归来的过程中solve
        head.next = null;
        return newHead;
    }
}
```  
![](./images/2022-04-07-17-37-42.png)
## 2. reverse list II
部分反转链表：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表。这里left指的是第left个元素，如left=2，第二个结点。
> leetcode 92

思路：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。  
步骤：使用三个指针变量pre，curr，next来记录反转的过程中的变量，curr指向待反转区域的第一个结点left，next永远指向curr的下一个结点，循环过程中，curr变化更新以后next会变化更新，pre永远指向待反转区域的第一个结点left的前一个结点，在循环过程中不变，不更新。
![](./images/2022-04-07-09-28-36.png)
![](./images/2022-04-08-14-01-11.png)


```java
class Solution {
    public ListNode reverseBetween (ListNode head, int left, int right) {
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;//定义dummy的next变量，才能表明dummy成为头结点，没有.next的只能称为头指针
        ListNode pre = dymmyNode;
        for (i = 0; i < left; i ++) {
            pre = pre.next;
        }
        ListNode curr = pre.next;
        ListNode next;
        for (i = 0; i < right - left + 1; i ++){
            next = curr.next; // 保存一下curr的后一个结点next，因为后面要更新
            curr.next = next.next;//断链，curr和后一个结点断开，curr.next指向后一个结点的后一个结点
            next.next = pre.next;// 接链，next的后一个结点变成pre.next, pre结点是不会更新的，永远指向left的前一个结点。在这里我之前错写成了 next.next=curr, 错在只看到了第一步的图，画到第二步就知道next.next应该指向pre.next，也就是待反转区域的原首结点。
            pre.next = next;//断链，pre和curr之间断开，pre.next指向next结点，这几步顺序不能换，否则会出现环。

        }
    }
}
```
## 3. Middle node of linked list
给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。  
思路：快慢指针，用一个slow指针每次只移动一个结点，而fast指针每次移动两个结点，当fast指针指向尾结点时，slow指针刚好在middle结点处。
>leecode 876
```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {  
            //关于奇偶的问题，当结点个数为偶数，两个中点，需返回后一个。奇数结点，一个中点，直接返回slow指针。  
            //奇数：fast的路线为1、3、5、、、、n，当fast到n时，fast.next = null  
            //此时slow走了（n+1）/2步，刚好到中点处，直接跳出循环返回slow  
            //偶数：fast的路线为1、3、5、、、、n-1,当fast到n-1时，下一次循环将会使fast直接等于null  
            //相当于最后一次循环fast 到了n+1个结点处，虽然不存在该结点  
            //此时slow走了(n+2)/2步，即n/2+1，刚好处于两个中点的后一个。
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```
## 4. Linked List Cycle
给你一个链表的头节点 head ，判断链表中是否有环。  
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。  
思路：使用快慢指针，如果链表中存在环，那么fast指针不会到空指针，因此和慢指针一定会相遇。
>leetcode 141
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```
* 注意：因为这里我们的循环条件是slow不等于fast，因此我们需要将slow和fast的初始位置分开，不能让他们都指向head，因此我们将他们一个指向head一个指向head.next。   

>leetcode 142

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null.
## 5. 

