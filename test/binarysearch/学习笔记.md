# binary search
## 1. basic operation  
条件：给定基本有序的数组，查找某个target是否存在，一般使用二分查找解决
```java
class solution{
    public int search(int[] nums, int target){
        if(nums == null || nums.length == 0){
            return -1; // 代码开头一定要先检查输入是否为空或者输入数组长度是否为0，前后顺序不能颠倒，因为java或语句先判断前面，假如nums为空，那么nums.length会产生空指针异常。
        }
        int left = 0;
        int right = nums.length - 1;
        int mid;
        while(left <= right){// 等号是为了最后就剩一个数的情况，此时left = right，可能刚好是我们的target，如果不是我们的target，下一次循环也会破坏循环不变式，left和right的关系被打破。
            mid = left + (right - left) / 2;//二分查找时，求取中间值的操作步骤，写法mid = (left + right) / 2，这种写法存在问题。原因：left可能不断增大，如果到极限状态，也就是left达到了right-1的地步的时候刚好数组的长度又很大，那么就可能导致left + right的溢出出现负数；4字节32bit的整型数据范围是- 2147483648~2147483647。
            if(nums[mid] == target){
                return mid;
            }
            else if(nums[mid] < target){
                left = mid + 1; // 这里不能写成left = mid，如前面讨论的，二分查找倒数第二步剩两个数，此时我们开始把左侧的数当作mid，因为取整，如果我们这里再把left写成mid，而恰好要走这个分支的话，那么就是死循环。下面同理。
            }
            else{
                right = mid - 1;
            }
        }
        return -1;
    }
}
```  
## 2. first occurrence
