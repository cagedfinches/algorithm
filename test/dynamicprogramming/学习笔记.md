## 1. 剪绳子问题

>leetcode 剑指offer14-1

```java
class Solution {
    public int cuttingRope(int n) {
        int[] m = new int[n + 1];
        m[0] = 0;
        m[1] = 0;
        m[2] = 1;
        for (int i = 3; i <= n; i ++){
            int max = 0;
            for (int j = 1; j < i; j++){
                //max = Math.max(max, j * Math.max(i - j, m[i - j])); // 切右段不切左段，且要考虑右段不切的情况
                max = Math.max(max, Math.max(j, m[j]) * (i - j)); // 切左段不切右段，j不需要等于i，因为m[0]为0，相乘肯定是0。
            }
            m[i] = max;
        }
        return m[n];
    }
}
```

```java
class Solution {
    public int cuttingRope(int n) {
        int[] m = new int[n + 1];
        for (int i = 0; i <= n; i ++){ // 如果不加base case边界条件，让绳子长度从0开始也可以。
            int max = 0;
            for (int j = 1; j < i; j++){
                //max = Math.max(max, j * Math.max(i - j, m[i - j])); // 切右段不切左段，且要考虑右段不切的情况
                max = Math.max(max, Math.max(j, m[j]) * (i - j)); // 切左段不切右段，j不需要等于i，因为m[0]为0，相乘肯定是0。
            }
            m[i] = max;
        }
        return m[n];
    }
}
```
TC: O(n^2);
Sc: O(n);


## 2. array hopper (jump game)

>leetcode 55

贪心算法，在每个能跳跃的最远距离内，挨个计算下一个能跳到的最远距离，只要这个最远距离能比最后的数组位置大就行。每次都贪心的选择了最远的距离。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int rightmost = 0;
        for (int i = 0; i < nums.length; i++){
            if (i <= rightmost){
                rightmost = Math.max(rightmost, i + nums[i]);
            }
            if (rightmost >= nums.length - 1){
                return true;
            }
        }
        return false;
    }
}
```
TC: O(n);
SC: O(1);

## 3. array hopper(jump game) II

>leetcode 45
贪心算法，每次都直接跳当前范围内能跳的最远距离，就能保证跳的次数最少。

```java
class Solution {
    public int jump(int[] nums) {
        int res = 0;
        int start = 0;
        int end = 1;
        while(end < nums.length){
            int rightmost = 0;
            for (int i = start; i < end; i ++){
                rightmost = Math.max(rightmost, i + nums[i]);
            }
            start = end; // 下次跳跃的起始位置；
            end = rightmost + 1; // 下次跳跃的结束位置；
            res ++; // 跳跃次数
        }
        return res;
    }
}
```
TC: O(n);
SC: O(1);

## 4. largest subarray sum 最大子数组和

>leetcode 53

[理解动态规划](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)这个链接里讲到了动态规划的一些步骤和理解，怎样定义子问题，什么是子问题的无后效性，怎样定义要填的表，怎么定义状态转移方程，思考初始值，最后进行空间优化。

```java
// 解法一
public class Solution {

    public int maxSubArray(int[] nums) {
        int len = nums.length;
        // dp[i] 表示：以 nums[i] 结尾的连续子数组的最大和
        int[] dp = new int[len];
        dp[0] = nums[0];

        for (int i = 1; i < len; i++) {
            if (dp[i - 1] > 0) {
                dp[i] = dp[i - 1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
        }

        // 也可以在上面遍历的同时求出 res 的最大值，这里我们为了语义清晰分开写，大家可以自行选择
        int res = dp[0];
        for (int i = 1; i < len; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}

// 解法二
// 空间优化
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int res = nums[0];
        for (int i = 0; i < nums.length; i++){
            pre = Math.max(pre + nums[i], nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}

```

## 5. dictionary word I

>leetcode 139

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String word : wordDict) set.add(word);
        int n = s.length();
        boolean[] f = new boolean[n + 10];
        f[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i && !f[i]; j++) {
                String sub = s.substring(j - 1, i);
                if (set.contains(sub)) f[i] = f[j - 1]; 
            }
        }
        return f[n];
    }
}
```

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

## 6. 斐波那契数列

>leetcode 10-1 剑指offer

```java
class Solution {
    public int fib(int n) {
        if (n <= 1){
            return n;
        }
        int[] fb = new int[n + 1];
        fb[0] = 0;
        fb[1] = 1;
        for (int i = 2; i <= n; i++){
            fb[i] = fb[i - 1] + fb[i - 2];
        }
        return fb[n];
    }
}
```

空间优化

```java
class Solution {
    public int fib(int n) {
        if (n <= 1){
            return n;
        }
        final int MOD = 1000000007;
        int res = 0;
        int a = 0;
        int b = 1;
        for (int i = 2; i <= n; i++){
            res = (a + b) % MOD;
            a = b;
            b = res;
        }
        return res;
    }
}
```
TC: O(n);
SC: O(1);

采用矩阵的快速幂，可以将时间复杂度降至O(log n);

## 7. 最长连续递增序列

>leetcode 674

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length <= 1)
            return nums.length;
        int ans = 1;
        int count = 1;
        for(int i=0;i<nums.length-1;i++) {
            if(nums[i+1] > nums[i]) {
                count++;
            } else {  
                count = 1;
            }
            ans = count > ans ? count : ans;
        }
        return ans;

    }
}
```

## 8. 正则表达式匹配

>leetcode 10 

宫水三叶，主要的困难就是在状态转移方程的推导，子问题的定义，看下她的数学推导过程吧。尤其是第三个if分支。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length();
        int m = p.length();    
        s = " " + s;
        p = " " + p;
        char[] ss = s.toCharArray();
        char[] pp = p.toCharArray();
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i ++){
            for (int j = 1; j <= m; j++){
                if (j + 1 <= m && pp[j + 1] == '*'){
                    continue;
                }
                if (i - 1 >= 0 && pp[j] != '*'){
                    f[i][j] = f[i - 1][j - 1] && (ss[i] == pp[j] || pp[j] == '.');
                }
                else if (pp[j] == '*'){
                    f[i][j] = (j - 2 >= 0 && f[i][j - 2]) || (i - 1 >= 0 && f[i - 1][j] && (ss[i] == pp[j - 1] || pp[j - 1] == '.'));
                }
            }
        }
        return f[n][m];
    }
}
```

TC: O(nm);
SC: O(nm);

## 9. 解码方法

>leetcode 91

```java

```
