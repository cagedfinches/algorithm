- [1. 剪绳子问题](#1-剪绳子问题)
- [2. array hopper (jump game)](#2-array-hopper-jump-game)
- [3. array hopper(jump game) II](#3-array-hopperjump-game-ii)
- [4. largest subarray sum 最大子数组和](#4-largest-subarray-sum-最大子数组和)
- [5. dictionary word I](#5-dictionary-word-i)
- [6. 斐波那契数列](#6-斐波那契数列)
- [7. 最长连续递增序列](#7-最长连续递增序列)
- [8. 正则表达式匹配](#8-正则表达式匹配)
- [9. 解码方法](#9-解码方法)
- [10. 最长公共子序列](#10-最长公共子序列)
- [11. 不同的子序列](#11-不同的子序列)
- [12. 打家劫舍](#12-打家劫舍)
- [13. 打家劫舍 II](#13-打家劫舍-ii)
- [14. 解码方法II](#14-解码方法ii)
- [dp里的路径问题](#dp里的路径问题)
  - [15. 不同路径](#15-不同路径)
  - [16. 不同路径II](#16-不同路径ii)
  - [17.](#17)



* [理解动态规划](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)这个链接里讲到了动态规划的一些步骤和理解，怎样定义子问题，什么是子问题的无后效性，怎样定义要填的表，怎么定义状态转移方程，思考初始值，最后进行空间优化。
* [宫水三叶关于动态规划的一些总结，也提到了无后效性](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485037&idx=1&sn=d6d52c48600e655161e84f25d3402514&scene=21#wechat_redirect)
* [关于无后效性的通俗理解](https://blog.csdn.net/skh2015java/article/details/115873380)  「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。「更加的学术表达是：当前某个状态确定后，之后的状态转移与之前的决策无关」


## 1. 剪绳子问题

>leetcode 剑指offer14-1

```java
class Solution {
    public int cuttingRope(int n) {
        int[] m = new int[n + 1];
        m[0] = 0;
        m[1] = 0;
        m[2] = 1;
        for (int i = 3; i <= n; i ++){
            int max = 0;
            for (int j = 1; j < i; j++){
                //max = Math.max(max, j * Math.max(i - j, m[i - j])); // 切右段不切左段，且要考虑右段不切的情况
                max = Math.max(max, Math.max(j, m[j]) * (i - j)); // 切左段不切右段，j不需要等于i，因为m[0]为0，相乘肯定是0。
            }
            m[i] = max;
        }
        return m[n];
    }
}
```

```java
class Solution {
    public int cuttingRope(int n) {
        int[] m = new int[n + 1];
        for (int i = 0; i <= n; i ++){ // 如果不加base case边界条件，让绳子长度从0开始也可以。
            int max = 0;
            for (int j = 1; j < i; j++){
                //max = Math.max(max, j * Math.max(i - j, m[i - j])); // 切右段不切左段，且要考虑右段不切的情况
                max = Math.max(max, Math.max(j, m[j]) * (i - j)); // 切左段不切右段，j不需要等于i，因为m[0]为0，相乘肯定是0。
            }
            m[i] = max;
        }
        return m[n];
    }
}
```
TC: O(n^2);
Sc: O(n);


## 2. array hopper (jump game)

>leetcode 55

贪心算法，在每个能跳跃的最远距离内，挨个计算下一个能跳到的最远距离，只要这个最远距离能比最后的数组位置大就行。每次都贪心的选择了最远的距离。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int rightmost = 0;
        for (int i = 0; i < nums.length; i++){
            if (i <= rightmost){
                rightmost = Math.max(rightmost, i + nums[i]);
            }
            if (rightmost >= nums.length - 1){
                return true;
            }
        }
        return false;
    }
}
```
TC: O(n);
SC: O(1);

## 3. array hopper(jump game) II

>leetcode 45
贪心算法，每次都直接跳当前范围内能跳的最远距离，就能保证跳的次数最少。

```java
class Solution {
    public int jump(int[] nums) {
        int res = 0;
        int start = 0;
        int end = 1;
        while(end < nums.length){
            int rightmost = 0;
            for (int i = start; i < end; i ++){
                rightmost = Math.max(rightmost, i + nums[i]);
            }
            start = end; // 下次跳跃的起始位置；
            end = rightmost + 1; // 下次跳跃的结束位置；
            res ++; // 跳跃次数
        }
        return res;
    }
}
```
TC: O(n);
SC: O(1);

## 4. largest subarray sum 最大子数组和

>leetcode 53

[理解动态规划](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)这个链接里讲到了动态规划的一些步骤和理解，怎样定义子问题，什么是子问题的无后效性，怎样定义要填的表，怎么定义状态转移方程，思考初始值，最后进行空间优化。

```java
// 解法一
public class Solution {

    public int maxSubArray(int[] nums) {
        int len = nums.length;
        // dp[i] 表示：以 nums[i] 结尾的连续子数组的最大和
        int[] dp = new int[len];
        dp[0] = nums[0];

        for (int i = 1; i < len; i++) {
            if (dp[i - 1] > 0) {
                dp[i] = dp[i - 1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
        }

        // 也可以在上面遍历的同时求出 res 的最大值，这里我们为了语义清晰分开写，大家可以自行选择
        int res = dp[0];
        for (int i = 1; i < len; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}

// 解法二
// 空间优化
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int res = nums[0];
        for (int i = 0; i < nums.length; i++){
            pre = Math.max(pre + nums[i], nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}

```

## 5. dictionary word I

>leetcode 139

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String word : wordDict) set.add(word);
        int n = s.length();
        boolean[] f = new boolean[n + 10];
        f[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i && !f[i]; j++) {
                String sub = s.substring(j - 1, i);
                if (set.contains(sub)) f[i] = f[j - 1]; 
            }
        }
        return f[n];
    }
}
```

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

## 6. 斐波那契数列

>leetcode 10-1 剑指offer

```java
class Solution {
    public int fib(int n) {
        if (n <= 1){
            return n;
        }
        int[] fb = new int[n + 1];
        fb[0] = 0;
        fb[1] = 1;
        for (int i = 2; i <= n; i++){
            fb[i] = fb[i - 1] + fb[i - 2];
        }
        return fb[n];
    }
}
```

空间优化

```java
class Solution {
    public int fib(int n) {
        if (n <= 1){
            return n;
        }
        final int MOD = 1000000007;
        int res = 0;
        int a = 0;
        int b = 1;
        for (int i = 2; i <= n; i++){
            res = (a + b) % MOD;
            a = b;
            b = res;
        }
        return res;
    }
}
```
TC: O(n);
SC: O(1);

采用矩阵的快速幂，可以将时间复杂度降至O(log n);

## 7. 最长连续递增序列

>leetcode 674

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length <= 1)
            return nums.length;
        int ans = 1;
        int count = 1;
        for(int i=0;i<nums.length-1;i++) {
            if(nums[i+1] > nums[i]) {
                count++;
            } else {  
                count = 1;
            }
            ans = count > ans ? count : ans;
        }
        return ans;

    }
}
```

## 8. 正则表达式匹配

>leetcode 10 

宫水三叶，主要的困难就是在状态转移方程的推导，子问题的定义，看下她的数学推导过程吧。尤其是第三个if分支。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length();
        int m = p.length();    
        s = " " + s;
        p = " " + p;
        char[] ss = s.toCharArray();
        char[] pp = p.toCharArray();
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i ++){
            for (int j = 1; j <= m; j++){
                if (j + 1 <= m && pp[j + 1] == '*'){
                    continue;
                }
                if (i - 1 >= 0 && pp[j] != '*'){
                    f[i][j] = f[i - 1][j - 1] && (ss[i] == pp[j] || pp[j] == '.');
                }
                else if (pp[j] == '*'){
                    f[i][j] = (j - 2 >= 0 && f[i][j - 2]) || (i - 1 >= 0 && f[i - 1][j] && (ss[i] == pp[j - 1] || pp[j - 1] == '.'));
                }
            }
        }
        return f[n][m];
    }
}
```

TC: O(nm);
SC: O(nm);

## 9. 解码方法

>leetcode 91

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        s = " " + s; // 加个空格在前面当哨兵，可以避免特殊判断前导零，还可以避免判断i - 1这种为负数的情况。
        char[] array = s.toCharArray();
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i <= n; i ++){
            int a = array[i] - '0';
            int b = (array[i - 1] - '0') * 10 + array[i] - '0';
            if (a >= 1 && a <= 9){
                f[i] = f[i - 1];
            }
            if (b >= 10 && b <= 26){ // 最重要的分支就是这里，如果b是10或者20的话，那么f[i]是直接等于f[i - 2]的，因为没有走上面的分支，如果b是11到19，21到26的话，那么其实f[i]就等于f[i - 1]加f[i - 2]了。
                f[i] = f[i] + f[i - 2];
            }
        }
        return f[n];
    }
}
```

TC: O(n);
SC: O(n);

空间优化，这里f[i]只和f[i - 1], f[i - 2]有关，所以我们可以直接换成三个变量，滚动变量。

```java
class Solution {
    public int numDecodings(String s){
        int n = s.length();
        s = " " + s;
        char[] array = s.toCharArray();
        int x = 0, y = 1, z = 0; // 这里x代表f[i -2], y 代表 f[i - 1], z 代表 f[i]，此时y就意味着初始状态，解码前一个字符的方法个数为1，第一个字符是空格。
        for (int i = 1; i <= n; i ++){
            int a = array[i] - '0';
            int b = (array[i - 1] - '0') * 10 + array[i] - '0';
            z = 0; // 在这里z一定要在每次循环开始重新置为0，因为我们更新x，y之后，z就只和x，y有关，不能受到上次z的结果的影响。
            if (a >= 1 && a <= 9){
                z = y;
            }
            if (b >= 10 && b <= 26){
                z = z + x;
            }
            x = y;
            y = z; 
        }
        return z;
    }
}
```

## 10. 最长公共子序列

>leetcode 1143

```java
class Solution {
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        //s1 = " " + s1;
        //s2 = " " + s2;
        char[] array1 = s1.toCharArray();
        char[] array2 = s2.toCharArray();
        int[][] f = new int[m + 1][n + 1];
        f[0][0] = 0;
        for (int i = 1; i <= m; i ++){
            for (int j = 1; j <= n; j ++){
                if (array1[i - 1] == array2[j - 1]){
                    f[i][j] = f[i - 1][j - 1] + 1;
                }
                else {
                    f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]);
                }
            }
        }
        return f[m][n];
    }
}
```

## 11. 不同的子序列

>leetcode 115

这里宫水三叶指出了[字符串匹配问题的一种状态普遍定义方法](https://leetcode.cn/problems/distinct-subsequences/solution/xiang-jie-zi-fu-chuan-pi-pei-wen-ti-de-t-wdtk/)

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        s = " " + s;
        t = " " + t;
        char[] array1 = s.toCharArray();
        char[] array2 = t.toCharArray();
        int[][] f = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i ++){
            f[i][0] = 1;
        }
        for (int i = 1; i <= m; i++){
            for (int j = 1; j <= n; j++){
                f[i][j] = f[i - 1][j];
                if (array1[i] == array2[j]){
                    f[i][j] += f[i - 1][j - 1];
                }
            }
        }
        return f[m][n];
    }
}
```

## 12. 打家劫舍

>leetcode 198

感觉官方题解要比宫水三叶的好理解一些。

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] f = new int[n + 1];
        f[0] = 0;
        f[1] = nums[0];
        for (int i = 2; i <= n; i ++){
            f[i] = Math.max(f[i - 2] + nums[i - 1], f[i - 1]); // 有偏移
        }
        return f[n];
    }
}
```
空间优化

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n <= 1){
            return nums[0];
        }
        int[] f = new int[n + 1];
        int a = 0;
        int b = nums[0];
        int res = 0;
        for (int i = 2; i <= n; i ++){
            res = Math.max(a + nums[i - 1], b);
            a = b;
            b = res;
        }
        return res;
    }
}

// 没有偏移

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1){
            return nums[0];
        }
        if (n == 2){
            return Math.max(nums[0], nums[1]);
        }
        int a = nums[0];
        int b = Math.max(nums[0], nums[1]);
        int res = 0;
        for (int i = 2; i < n; i ++){
            res = Math.max(a + nums[i], b);
            a = b;
            b = res;
        }
        return res;
    }
}
```

## 13. 打家劫舍 II

>leetcode 213

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        if (n == 2){
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }
    public int robRange(int[] nums, int start, int end){
        int[] f = new int[end - start + 1];
        f[0] = nums[start];
        f[1] = Math.max(nums[start], nums[start + 1]);
        for (int i = 2; i < end - start + 1; i ++){
            f[i] = Math.max(f[i - 2] + nums[start + i], f[i - 1]);
        }
        return f[end - start];
    }
}

// 空间优化

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        if (n == 2){
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
    }
    public int robRange(int[] nums, int start, int end){
        int a = nums[start];
        int b = Math.max(nums[start], nums[start + 1]);
        
        for (int i = start + 2; i <= end; i ++){ // 与之前的三变量滚动不同，双变量的滚动，可以保证b始终是我们要的那个结果，且能避免数组只有两个元素的特判。
            int temp = b;
            b = Math.max(a + nums[i], b);
            a = temp;
            
        }
        return b;
    }
}

```
## 14. 解码方法II

>leetcode 639

这个题分支太多，后续的空间优化，宫水三叶习惯使用滚动数组，待后续我添加进来，就能让空间复杂度优化为O(1)；

```java
class Solution {
    int mod = (int)1e9+7;
    public int numDecodings(String s) {
        int n = s.length();
        char[] array = s.toCharArray();
        long[]f = new long[n];
        f[0] = array[0] == '*' ? 9 : (array[0] != '0' ? 1 : 0);
        for (int i = 1; i < n; i ++){
            char c = array[i];
            char pre = array[i - 1];
            if (c == '*'){ // 当前字符为'*'
                // array[i] 单独作为一个item
                f[i] += f[i - 1] * 9;
                // array[i] 与前一个字符共同解码成一个item
                if (pre == '*'){
                    f[i] += (i - 2 >= 0 ? f[i - 2] : 1) * 15;
                }
                else {
                    int digit = pre - '0';
                    if (digit == 1){
                        f[i] += (i - 2 >= 0 ? f[i - 2] : 1) * 9;
                    }
                    else if (digit == 2){
                        f[i] += (i - 2 >= 0 ? f[i - 2] : 1) * 6;
                    }
                }
            }
            else { // 当前字符为正常数字
                int digit = c - '0';
                if (pre == '*'){ // 上一个字符为'*'
                    if (digit == 0){
                        f[i] = (i - 2 >= 0 ? f[i - 2] : 1) * 2;
                    }
                    else { 
                        // array[i] 单独作为一个item
                        f[i] = f[i - 1];
                        // array[i] 和前一个字符共同作为一个item
                        if (digit <= 6){
                            f[i] += (i - 2 >= 0 ? f[i - 2] : 1) * 2;
                        }
                        else {
                            f[i] += i - 2 >= 0 ? f[i - 2] : 1;
                        }
                    }
                }
                else { // 上一个字符为正常数字
                    int number = pre - '0';
                    if (digit == 0){
                        if (number == 1 || number == 2){
                            f[i] = i - 2 >= 0 ? f[i - 2] : 1;
                        }
                    }
                    else {
                        // array[i] 单独作为一个item
                        f[i] = f[i - 1];
                        // array[i] 和上一个字符共同作为一个item
                        if (number == 1){
                            f[i] += i - 2 >= 0 ? f[i - 2] : 1;
                        }
                        else if (number == 2 && digit <= 6){
                            f[i] += i - 2 >= 0 ? f[i - 2] : 1;
                        }
                    }
                }
            }
            f[i] %= mod;
        }
        return (int)f[n - 1];
    }
}
```

# dp里的路径问题

## 15. 不同路径

>leetcode 62

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        f[0][0] = 1;
        for (int i = 0; i < m; i ++){
            for (int j = 0; j < n; j ++){
                if(i > 0  && j > 0){
                    f[i][j] = f[i][j - 1] + f[i - 1][j];
                }
                else if (j > 0){
                    f[i][j] = f[i][j - 1];
                }
                else if (i > 0){
                    f[i][j] = f[i - 1][j];
                }
            }
        }
        return f[m - 1][n - 1];
    }
}
```

## 16. 不同路径II

>leetcode 63

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] f = new int[m][n];
        f[0][0] = 1;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j ++){
                if(obstacleGrid[i][j] == 1){
                    f[i][j] = 0;
                }
                else {
                    if (i > 0 && j > 0){
                        f[i][j] = f[i - 1][j] + f[i][j - 1];
                    }
                    else if (i > 0){
                        f[i][j] = f[i - 1][j];
                    }
                    else if (j > 0){
                        f[i][j] = f[i][j - 1];
                    }
                }
            }
        }
        return f[m - 1][n - 1];
    }
}
```
## 17. 最小路径和

>leetcode 64 

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] f = new int[m][n];
        f[0][0] = grid[0][0];
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j ++){
                if (i > 0 && j > 0){
                    f[i][j] = Math.min(f[i - 1][j] + grid[i][j], f[i][j - 1] + grid[i][j]);
                }
                else if (i > 0){
                    f[i][j] = f[i - 1][j] + grid[i][j];
                }
                else if (j > 0){
                    f[i][j] = f[i][j - 1] + grid[i][j];
                }
            }
        }
        return f[m - 1][n - 1];
    }
}
```

## 18. 三角形最小路径和

[滚动数组的概念](https://juejin.cn/post/6854573217185529864)
[位运算和取余](https://www.jianshu.com/p/0711e9eb8cef)

>leetcode 120

```java
// tc: O(n^2)
// sc: O(n^2)
class Solution {
    public int minimumTotal(List<List<Integer>> tri) {
        int n = tri.size();
        int ans = Integer.MAX_VALUE;
        int[][] f = new int[n][n];
        f[0][0] = tri.get(0).get(0);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                int val = tri.get(i).get(j);
                f[i][j] = Integer.MAX_VALUE;
                if (j != 0) f[i][j] = Math.min(f[i][j], f[i - 1][j - 1] + val);
                if (j != i) f[i][j] = Math.min(f[i][j], f[i - 1][j] + val);
            }
        }
        for (int i = 0; i < n; i++) ans = Math.min(ans, f[n - 1][i]);
        return ans;
    }
}


// 空间优化
class Solution {
    public int minimumTotal(List<List<Integer>> tri) {
        int n = tri.size();
        int ans = Integer.MAX_VALUE;
        int[][] f = new int[2][n];
        f[0][0] = tri.get(0).get(0);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i + 1; j++) {
                int val = tri.get(i).get(j);
                f[i & 1][j] = Integer.MAX_VALUE;
                if (j != 0) f[i & 1][j] = Math.min(f[i & 1][j], f[(i - 1) & 1][j - 1] + val);
                if (j != i) f[i & 1][j] = Math.min(f[i & 1][j], f[(i - 1) & 1][j] + val);
            }
        }
        for (int i = 0; i < n; i++) ans = Math.min(ans, f[(n - 1) & 1][i]);
        return ans;
    }
}
```

## 19. 下降路径最小和

>leetcode 931 

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        int[][] f = new int[n][n];
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++){
            f[0][i] = matrix[0][i];
        }
        for (int i = 1; i < n; i++){
            for (int j = 0; j < n; j++){
                int val = matrix[i][j];
                f[i][j] = Integer.MAX_VALUE;
                if (j == 0){
                    f[i][j] = Math.min(f[i - 1][j] + val, f[i - 1][j + 1] + val);
                }
                else if (j == n - 1){
                    f[i][j] = Math.min(f[i - 1][j] + val, f[i - 1][j - 1] + val);
                }
                else {
                    f[i][j] = Math.min(f[i - 1][j] + val, f[i - 1][j - 1] + val);
                    f[i][j] = Math.min(f[i][j], f[i - 1][j + 1] + val);
                }
            }
        }
        for (int i = 0; i < n; i ++){
            res = Math.min(res, f[n - 1][i]);
        }
        return res;
    }
}
```

# 背包dp

## 1. 从0-1背包问题开始讲起

[宫水三叶从0-1背包问题开始讲起](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485638&idx=1&sn=d7468955c5b121664031fd5c1b5a6f10&chksm=fd9ca3d9caeb2acf2dd4e9f512b2d4dc820107489a094749ffe7cae646f0cc60de06f2d18898&scene=178&cur_album_id=1748759632187047943#rd)

这是一种给定价值与成本，限定决策规则的情况下，怎样在有限容量内做到价值最大化的问题。

二维dp，一个维度是第i个物品，另一个维度是剩余容量。
状态定义：考虑前i件物品，使用容量不超过C的条件下的背包最大价值。

![](images/2023-01-30-20-54-58.png)

背包问题的一维空间优化是求解其他背包问题的基础，需要掌握。

```java
class Solution {
    public int maxValue(int N, int C, int[] v, int[] w) {
        int[] dp = new int[C + 1];
        for (int i = 0; i < N; i++) {
            for (int j = C; j >= v[i]; j--) {
                // 不选该物品
                int n = dp[j]; 
                // 选择该物品
                int y = dp[j-v[i]] + w[i]; 
                dp[j] = Math.max(n, y);
            }
        }
        return dp[C];
    }
}
```
为什么倒过来计算就可以将空间优化为一维？

第0个位置，dp[0]~dp[v[0]]均为0，dp[v[0]+1]~dp[C]均为第0个物品的价值；
第1个位置，假设物品1的重量比物品0的大，那么dp[C]~dp[v[0]+v[1]]均为第0个和第一个物品的价值和，dp[v[0]+v[1]]~dp[v[1]]均为第1个物品的价值，dp[v[1]]~dp[v[0]]均为第0个物品的价值，dp[v[0]]~dp[0]均为0。

以此类推。

这个其实不用倒过来计算也可以把空间降为一维，就把上面的代码和优化之前一样，先把dp数组初始化为第0个物品的情况，之后内部循环那里j从0开始到C，y那里加个判断条件不要越界，应该可行。

## 2. 分割等和子集

这里宫水三叶提到如何把一个问题转化为0-1背包问题，也就是在限定成本内价值最大化的问题。
问题等效于「能否从数组中挑选若干个元素，使得元素总和等于所有元素总和的一半」。这个题的价值和容量均为数值和。
直接套用背包问题的状态定义。
这个题的状态定义如下：f[i][j]代表前i个数，选择的数数值总和不大于j的最大数值总和。

>leetcode 416

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        
        for (int i = 0; i < n; i ++){
            sum  += nums[i];
        }
        if (sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        int[][] f = new int[n][target + 1];
        // 边界值的设定
        for (int j = 0; j <= target; j++){
            f[0][j] = j >= nums[0] ? nums[0] : 0;
        }
        // 状态转移

        for (int i = 1; i < n; i++){
            int t = nums[i];
            for (int j = 0; j <= target; j++){
                // 不选第i件物品
                int no = f[i - 1][j];
                // 选第i件物品
                int yes = j >= t ? f[i - 1][j - t] + t : 0;
                f[i][j] = Math.max(yes, no);
            }
        }

        return f[n - 1][target] == target;

    }
}

// 空间优化，第一种是滚动数组，第二种直接降为一维，将容量遍历方向改为从大到小。
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;

        //「等和子集」的和必然是总和的一半
        int sum = 0;
        for (int i : nums) sum += i;
        int target = sum / 2;

        // 对应了总和为奇数的情况，注定不能被分为两个「等和子集」
        if (target * 2 != sum) return false;

        // 将「物品维度」取消
        int[] f = new int[target + 1];
        for (int i = 0; i < n; i++) {
            int t = nums[i];
            // 将「容量维度」改成从大到小遍历
            for (int j = target; j >= 0; j--) {
                // 不选第 i 件物品
                int no = f[j];
                // 选第 i 件物品
                int yes = j >= t ? f[j-t] + t : 0;
                f[j] = Math.max(no, yes);
            }
        }
        // 如果最大价值等于 target，说明可以拆分成两个「等和子集」
        return f[target] == target;
    }
}
```