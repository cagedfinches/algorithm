# Tree
- [Tree](#tree)
  - [1. 利用栈实现二叉树遍历的非递归算法](#1-利用栈实现二叉树遍历的非递归算法)
  - [2. 二叉树的中序遍历](#2-二叉树的中序遍历)
  - [3. same tree](#3-same-tree)
  - [4. 树是否对称](#4-树是否对称)
  - [5. 递归、栈、队列、空间复杂度](#5-递归栈队列空间复杂度)
  - [6. 二叉树最大深度](#6-二叉树最大深度)
  - [7. 二叉树层序遍历](#7-二叉树层序遍历)
## 1. 利用栈实现二叉树遍历的非递归算法
树的前中后序遍历既可以用简单的递归来实现，也可以用栈来实现非递归的算法。  
普遍思路就是把目前无法访问的结点放入栈中，而后再退栈访问。  
* 先看前序遍历：
![](images/2022-04-28-15-02-40.png)
前序遍历是根左右的顺序，访问a，访问b，都可以访问，但访问a的时候我们要将a的右孩子c入栈，因为此时c无法被访问，之后我们还需要返回访问右子树。同理，访问b的时候要将b的右孩子d入栈，因为访问
b的时候d无法被访问。  
* 总体思路：非递归写法，while循环，先visit当前结点，如果右孩子不为空，将右孩子入栈，如果左孩子不为空，直接将指向当前结点的指针指向左孩子，如果左孩子为空，直接从栈顶弹出一个结点并把这个结点当作当前结点继续进循环。  
![](images/2022-04-28-15-23-45.png)
![](images/2022-04-28-15-24-28.png)

* 中序遍历：  
  利用栈实现中序遍历的非递归算法，总体思路还是要把暂时无法访问处理的结点入栈。 
  ![](images/2022-04-28-16-17-33.png)
中序遍历，左根右，访问a时，a无法访问，进栈，进而访问b，b无法访问，进栈，进而访问b左孩子，b左孩子为空，退栈，访问b，访问b的时候b的右孩子d无法访问，d入栈，p指针指向d的左孩子，d的左孩子为空，即p为空，则退栈，访问退栈的结点d，p移向退栈结点d的右孩子，d的右孩子为空，p为空，退栈，访问退栈的结点a，p移向退栈结点的右孩子c，右孩子c不为空，进栈。只要栈不空，重复这个过程。
  ![](images/2022-04-28-16-46-34.png)
* 后序遍历：  
  ![](images/2022-04-28-16-54-26.png)
  ![](images/2022-04-28-16-55-32.png)
  ![](images/2022-04-28-16-55-58.png)
  ![](images/2022-04-28-16-56-14.png)

* 用队列实现层序遍历：
  ![](images/2022-04-28-16-58-40.png)
  ```c++
  template <class T>
     void BinaryTree<T>::levelOrder (void (*visit)     (BinTreeNode<T> *t)) {
     if (root == NULL) return;
     Queue<BinTreeNode<T> * > Q;
     BinTreeNode<T> *p = root;   
     visit (p);   Q.EnQueue (p); 	
     while (!Q.IsEmpty ()) {
          Q.DeQueue (p);
          if (p->leftChild != NULL) { 
              visit (p->leftChild);
               Q.EnQueue (p->leftChild);
          }
          if (p->rightChild != NULL) {
               visit (p->rightChild);
               Q.EnQueue (p->rightChild);
          }
     }
  }
  ```
## 2. 二叉树的中序遍历
>leetcode 94  

简单的中序遍历，使用学过的递归算法即可解决。
![](images/2022-05-01-19-26-58.png)
思路：递归
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        getAns(res, root);//这里需要注意我们输出的是一个可变数组表arraylist，我们在方法内部构建了这样一个对象
        // 那么我们就不能再用递归直接递归本函数，因为这个对象会被重新例化，我们不需要重新例化，因此这里用另一个函数进行递归，保证arraylist对象不被重新例化。
        return res;
    }
    public void getAns(List<Integer> res, TreeNode root){
        if (root == null){
            return;
        }
        getAns(res,root.left);
        res.add(root.val);
        getAns(res,root.right);
    }
}
```
* 复杂度分析  
  时间复杂度：$O(n)$，每个结点遍历一次，递归树方法画一下，每层全部加起来就是所有结点的数量。分治法的divide和merge复杂度是$O(1)$。
  空间复杂度：$O(n)$，取决于递归的栈深度，最差情况就是二叉树一条链，总共压栈n次。

## 3. same tree
>leetcode 100 

判断两个树是否完全一样。
思路：递归遍历。
```java
class Solution {// 注意一下递归的写法，递归中止条件在哪，if else elseif 怎么使用， return的位置等，别绕进去。
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null){
            return true;
        }
        else if (p == null || q == null){
            return false;
        }
        if (isSameTree(p.left, q.left) && isSameTree(p.right, q.right) && (p.val == q.val)){
            return true;
        }
        return false;
    }
}
```

## 4. 树是否对称
>leetcode 101

思路：递归，判断树是否对称，就是判断树的左右子树是否对称，即子问题为左子树的左子树是否等于右子树的右子树，左子树的右子树是否等于右子树的左子树，满足了这两个条件，这棵树就是对称的。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        TreeNode p = root.left;
        TreeNode q = root.right;
        return isEqual(p, q);

    }
    public boolean isEqual(TreeNode p, TreeNode q){
        if (p == null && q == null){
            return true;
        }
        else if (p == null || q == null){
            return false;
        }
        else {
            return isEqual(p.left, q.right)&&isEqual(p.right, q.left)&&(p.val == q.val); // 关键在于p.left要和q.right比较，而p.right要和q.left进行比较。
        }
    }
}
```
## 5. 递归、栈、队列、空间复杂度

* 递归和栈的关系：每一次递归调用，或者函数调用时，需要为过程中使用的参数，局部变量等另外分配存储空间，每层递归调用需分配的空间形成递归工作记录，按后进先出的栈组织。
* ![](images/2022-05-02-16-12-16.png)
* 在递归过程中，碰到无法解决的子问题，先将子问题进栈，直到递归边界，回溯时从栈顶依次出栈。
* 涉及到递归算法的空间复杂度要看压栈的规模，在二叉树的递归算法中，如中序遍历，最差空间复杂度是二叉树一条链的情况，此时我们的递归深度就是这条链的长度。但假如是满二叉树的情况，我们的递归深度其实只有树的高度$log(n)$大小，因为我们其实在递归左子树的时候一直沿左子树往下，下到叶节点，中途压栈的都是左节点的递归，递归回溯的时候就开始退栈了，所以栈的规模始终不超过$log(n)$。
* 栈是深度优先，队列是广度优先。从上面采用栈实现前中后序遍历，使用队列实现层序遍历即可知道。

## 6. 二叉树最大深度
>leetcode 104

## 7. 二叉树层序遍历
