# 子串

## 1. 和为k的子数组

>leetcode 560

直接看官方题解。

大体思路就是，前缀和加上哈希表。

前缀和pre[i]，代表第i个数之前的前缀和。那么如果我们要求和为k的子串，假如这个子串在[j, i]区间内，就有pre[i] - pre[j - 1] = k，变换一下这个式子，那就是pre[j - 1] = pre[i] - k; 怎么理解呢，就是说当我们计算到pre[i]的时候，如果前面有一个pre[j - 1]满足上式，那么不就刚好两个前缀和之间的差值是k吗，那么不就意味着找到一个子串了吗，这子串就在两个前缀和之间。

哈希表要做的就是记录pre前缀和的出现频次，比如有的前缀和出现了两次，那么在计算子串个数的时候这两个都得加上，不能漏掉。

pre没必要用数组来解决，因为它只和前一个值有关。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int pre = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for (int i = 0; i < nums.length; i++){
            pre += nums[i];
            if(map.containsKey(pre - k)){
                count += map.get(pre - k);
            }
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

这里只需要遍历整个数组一次，因此时间复杂度为O(n).

## 2. 滑动窗口最大值

>leetcode 239

* 解法一：优先队列

思路：要求滑动窗口的最大值，那么我们维护一个滑动窗口大小的优先队列，直接拿那个大顶堆的堆顶元素不就好了，很容易想到这种优先队列方法。

具体做法还需讨论：我们应该用什么作为优先队列排序的标准，肯定是nums[i]，也就是数组元素，但是只用数组元素做大顶堆的话，我们不知道当前的数组下标是什么，毕竟我们要计算一个窗口内的大顶堆，而不是目前为止第k大的大顶堆。因此我们这里选择把一个一维数组放进堆中，[i, nums[i]]，排序就按照nums[i]来排，用nums[i]构造出大顶堆。

最后，我们需要在数组下标到达首个窗口右端点的时候，把大顶堆的堆顶元素加入到结果集，而在窗口左端点比堆顶元素的下标大的时候，把堆顶元素弹出（因为如果窗口左端点比堆顶元素的下标大，那么就意味着此时堆中的最大值已经不在我们的窗口里了，应该舍弃掉）。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->b[1]-a[1]);
        int n = nums.length;
        int m = n - k + 1;
        int idx = 0;
        int[] res = new int[m];
        for (int i = 0; i < n; i++){
            pq.add(new int[]{i, nums[i]});
            if (i >= k - 1){
                while (pq.peek()[0] <= i - k){
                    pq.poll();
                }
                res[idx++] = pq.peek()[1];
            }
        }
        return res;
    }
}
```

时间复杂度：$O(n logn)$。优先队列的操作复杂度基本都是$O(logn)$。
空间复杂度：$O(n)$。

* 解法二：单调队列

等做完队列题再来补充。

