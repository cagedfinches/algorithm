# stack and queue
>参考链接 [java栈和队列的实现](http://www.codebaoku.com/it-java/it-java-226198.html) 写的非常全面，稍有改动。

>参考链接 [为什么不推荐使用Stack类实现java栈而是使用Deque](https://mp.weixin.qq.com/s/TSpWaYSUpjeR_wzSclCTQA)

>参考链接 [为什么也不太推荐ArrayDeque实现java栈](https://mp.weixin.qq.com/s/o6gnTbbKUODHBgRD7AYqUQ)

>参考链接 [接口Queue、Deque以及实现他们的类LinkedList和ArrayDeque之间的关系]

* 总结  
* stack：  
1. 采用链表实现，那就是头插法，头删法，才能保证后进先出或者先进后出。采用链表实现只需要一个head指针即可，采用头插法，头插法有没有哑结点操作都是相同的。  
2. 采用数组实现，尾插尾删，就是正常让数组按head下标不断往后插入，弹出也是直接弹出head下标位置的数，这样就可以实现后进先出，因为head下标始终指向最新进来的哪个数。
* queue：  
1. 采用链表实现，那就是尾插法，头删法，采用两个指针head和tail，才能保证先进先出。尾插法需要区分添加第一个结点的操作和后续的操作。添加第一个结点时需要让tail=newnode，后续添加其他结点时需要tail.next=newnode，tail=tail.next。
2. 采用数组实现，这里需要注意要使用循环队列的形式。具体来讲就是由于我们要实现先进先出，尽管我们可以加两个指针，但是我们在执行弹出操作的时候，始终需要将元素弹出后把后面的所有元素进行移动，以填补弹出造成的空缺。这里就会造成$O(n)$的时间复杂度。要想达到$O(1)$的时间复杂度，就要使用循环数组。即我们采用两个指针，head始终指向已经存放的元素的第一个下标，tail始终指向还未存放（可以存放）的位置的第一个下标。我们假定判断队空的标准是head= tail，那么我们给数组增加一个空位，所以判断队满的标准是（tail+1）% array.length = head。
*  deque：双端队列
1. 采用双向链表实现deque，我们的ListNode里需要增加一个pre指针，指向当前结点的上一个结点。这里我们的操作包括offerFirst，即从左侧向队列添加元素（相当于头插法），offerLast，从右侧向队列添加元素（相当于尾插法）。pollFirst，从左侧头部弹出元素，相当于头删法，pollLast，从右侧尾部弹出元素，相当于尾删法。

## 1. Implement stack using queues
>leetcode 225

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

思路：  
采用两个以链表为实现的队列，分别为q1，q2。入栈操作时，将元素offer进q2，然后将q1里的元素全部poll出来offer进q2，由于队列采用的时尾插头删法的先进先出，所以此时q2的前端即为最新进栈的元素，然后我们再将q1和q2互换。也就意味着我们要让q2始终为空，我们始终向一个空的队列先offer进一个元素，这个元素是最新进栈的元素，然后把在它之前进栈的从q1安排到q2的它后面，然后把q1和q2互换，让q2始终保持空。前端始终为最新进栈的元素，视为栈顶，后端始终为最先进栈的元素，视为栈底，这样就形成了一个栈。

从而poll和peek的操作也变得非常简单，直接从q1进行pop和peek即可。
![](./images/225_fig1.gif)
```java
class MyStack {
    private Queue<Integer> q1;
    private Queue<Integer> q2;
    public MyStack() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }
    
    public void push(int x) {
        q2.offer(x);
        while (!q1.isEmpty()){
            q2.offer(q1.poll());
        }
        Queue<Integer> tmp = q1;
        q1 = q2;
        q2 = tmp;

    }
    
    public int pop() {
        return q1.poll();
    }
    
    public int top() {
        return q1.peek();
    }
    
    public boolean empty() {
        return q1.isEmpty();
    }
}
```
* 复杂度分析
* 时间复杂度：只有push操作时间复杂度是$O(n)$，n代表当前栈内的规模。
* 空间复杂度：$O(n)$，其中n是栈内元素个数，需要两个队列来存储。



## 2. Implement queue using stacks
>leetcode 232

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：  
我们是否可以用第一题的方法实现第二题？也就是把栈和队列的身份互换？  
答案是不可以，画图可知。

思路：  
用两个栈实现队列，那么我们将一个栈负责往里push，我们称为s1，另一个栈负责往外pop，称为s2。这里的关键在于，在进行pop和peek操作时，如果s2空了，那么我们需要将s1里面的所有元素push进s2中，这样就可以实现先进先出。而之所以要等s2全部pop空之后再push，是因为如果我们在s2没有空之前将s1里的元素push进去，那么此时s2的栈顶就是最后进队的元素，而不是最先进队的元素。所以一定要等s2里的元素全部被pop出以后，才能把s1里的往s2里push，否则就一直往s1里push即可。


```java
class MyQueue {
    private Deque<Integer> s1;
    private Deque<Integer> s2;
    public MyQueue() {
        s1 = new ArrayDeque<>();
        s2 = new ArrayDeque<>();
    }
    
    public void push(int x) {
        s1.push(x);
    }
    
    public int pop() {
        if (s2.isEmpty()){
            while (!s1.isEmpty()){
                s2.push(s1.pop());
            }   
        }//s2空，就把s1里的全部push进s2，顺序刚好是最先进栈的在栈顶。
        return s2.pop();
    }
    
    public int peek() {
        if (s2.isEmpty()){
            while (!s1.isEmpty()){
                s2.push(s1.pop());
            }   
        }
        return s2.peek();
    }
    
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```
* 复杂度分析
* 时间复杂度：由于所有元素都会被压入栈两次，弹出两次，而一次压入或弹出的复杂度为$O(1)$，因此总的时间复杂度为$O(4n) = O(n)$。
* 空间复杂度：$O(n)$。用了两个栈，两个栈都可能达到n的规模，因此复杂度$O(2n)$。

## 3. Min stack
>leetcode 155
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 

思路：  
* 采用外加一个辅助栈的方式实现，每当我们向原栈中push进一个元素，我们都要往辅助栈中push进一个当前原栈中的最小元素。因此我们要记录一下当前原栈中的最小元素。当我们pop的时候，我们需要同步从辅助栈中pop出栈顶元素，从而让我们的辅助栈栈顶始终保持着当前原栈中的最小元素。如果只同步push而不同步pop，那么辅助栈的栈顶元素会是所有曾经push进原栈的数据的最小元素而不是当前原栈的。
* ![](./images/155_fig1.gif)
```java
class Minstack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;
    public Minstack(){
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
    }
    public void push(int val){
        xStack.push(val);
        minStack.push(Math.min(minStack.peek(),val));
    }
    public void pop(){
        xStack.pop();
        minStack.pop();
    }
    public int top(){
        return xStack.peek();
    }
    public int getMin(){
        return minStack.peek();
    }
}
```
* 复杂度分析
* 时间复杂度：$O(1)$，因为我们每个操作都是$O(1)$时间，push，pop，getMin都是$O(1)$时间。
* 空间复杂度：$O(n)$，因为要用两个栈存储数据，两个栈的规模都可以达到n，n代表我们要push进的数据规模。

## 4. 逆波兰表达式
